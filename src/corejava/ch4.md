# 对象与类

### 类
>类(class)是构造对象的模板或蓝图。又类构造(construct)对象的过程称为创建类的实例(instance)

### 对象
对象的三个主要特征：

- 对象的行为(behavior)——可以对对象施加哪些操作，或可以对对象施加哪些方法？
- 对象的状态(state)——当施加那些方式时，对象如何响应？
- 对象的标识(identity)——如何辨别具有相同行为和状态的不同对象？

### 对象和对象变量
- 对象可以理解为一块内存。如new Date();
- 对象变量可以理解为一个对象的引用或指针。如Date date = new Date();
- **所有java对象都存储在堆中**

### 构造器
- 构造器与类同名
- 每个类可以又一个以上的构造器
- 构造器可以有0个、1个或多个参数
- 构造器没有返回值
- 构造器总是伴随着 new 操作一起调用

### final 实例域
- 构建对象时必须初始化
- 类似于cpp的顶层指针

### 静态域
>如果将域定义为 static，每个类中只有一个这样的域。它属于类，而不属于任何独立
>的对象

### 静态方法
>静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有 this 参数的方法。
>但是，静态方法可以访问自身类中的静态域。

在下面两种情况下使用静态方法：
- 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供
- 一个方法只需要访问类的静态域
--------------------------------------------------------

## 方法参数
- 按值调用(call by value): 表示方法接收的是调用者提供的值
- 按引用调用(call by reference): 表示方法接收的是调用则提供的变量地址

>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，
>特别是，方法不能修改传递给它的任何参数变量的内容。

方法参数共有两种类型：
- 基本数据类型（数字、布尔值）。
- 对象引用。
>一个方法不可能修改一个基本数据的参数，但是可以修改对象引用的状态。

Java中方法参数使用情况的总结：
- 一个方法不能修改一个基本数据类型的参数。
- 一个方法可以改变一个对象参数的状态。
- 一个方法不能让对象参数引用一个新的对象。

-----------------------------------------
## 对象构造
### 重载
>如果多个方法有**相同的名字、不同的参数**，便产生了重载。

### 无参数的构造器
>如果在编写一个类的时候没有编写构造器，那么系统就会提供一个无参数构造器。
>
>如果类中提供了至少一个构造器，则系统不会提供无参数的构造器，
>需要用户自己编写。

### 显式域初始化
>在类定义中，可以直接将一个值赋给任何域。
```java
class Employee {
    private String name = "HP";
    . . .
}
```

### 调用另一个构造器
>如果构造器的第一个语句形如`this(...)`，这个构造器将调用同一个类的另一个构造器

**必须放在第一行**

### 初始化块
>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。
>无论初始化块在什么位置，都会首先运行初始化块，然后才运行构造器的主体部分。

```java
class Employee {
    private static int nextId = 1;

    private int id;
    private String name;
    private double salary;

    // object initialization block
    {
        id = nextId;
        nextId++;
    }

    public Employee(String n, double s) {
        name = n;
        salary = s;
    }

    public Employee() {
        name = "HP";
        salary = 1000;
    }
}
```

调用构造器的具体处理步骤：
1. 所有数据域被初始化为默认值（0、false 或 null）。
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
4. 执行这个构造器的主体。

## 类设计技巧
1. 一定要保证数据私有
2. 一定要对数据初始化
3. 不要在类中使用过多的基本类型
4. 不是所有的域都需要独立的域访问器和域更改器
5. 将职责过多的类进行分解
6. 类名和方法名要能够体现它们的职责
7. 优先使用不可变的类